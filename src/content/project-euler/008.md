---
title: "프로젝트 오일러 008"
published_date: 2024-10-26T12:00:49.000Z
modified_date: 2024-10-26T15:55:56.000Z
slug: project-euler-008
custom_excerpt: "1,000 개 숫자 중에서 연속된 숫자들의 곱의 최대값 찾기 feat. 고차함수"
feature_image: https://images.unsplash.com/photo-1644698245541-66a16547f247?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDJ8fGZhaWxlZCUyMHRvJTIwZmFpbHVyZXxlbnwwfHx8fDE3Mjk5MTk0NTl8MA&ixlib=rb-4.0.3&q=80&w=2000
category: ""
tags: ["#wordpress", "#Import 2024-10-22 00:39"]
---

### 문제

[8번 문제1000자리 수 안에서 연속된 13개 숫자 곱의
최댓값![](https://euler.synap.co.kr/favicon.ico)사이냅소프트![](https://euler.synap.co.kr/images/euler_portrait.png)](https://euler.synap.co.kr/problem=8)

1,000개의 한 자리 자연수가 있고, 이를 순서대로 13개씩 뽑아 (1...13, 2...14 이런 식으로) 모두 곱했을 때의 최대값을
찾는 문제입니다. 1000개의 숫자를 정수 리스트로 만들 수 있다면 연속된 부분열은 슬라이스 문법으로, 정수들의 곱은 reduce 명령으로
구할 수 있습니다.

초심자에게 까다로운 부분은 1000개의 숫자를 어떻게 정수로 만들 것인가 하는 부분입니다. 문제에 표시된 1000개의 숫자를 메모장이나
편집기에서 줄바꿈 없이 한 줄로 만든 후 소스코드에 붙여넣어도 되겠지만, 코드 한 줄이 길이가 지나치게 길어진다는 문제는 있겠네요.  

## 풀이

여기서는 원래 문제의 의견을 존중하여 한 줄에 50자씩 잘라놓은 문자열을 그대로 사용하도록 하겠습니다.

```python
from functools import reduce

product = lambda xs: reduce(lambda x, y: x * y, xs)
chunk_size = 13
s = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450 
"""

def solve():
    ns = list(map(int, (c for c in s if c.isdigit())))
    return max(product(ns[i:i+chunk_size]) for i in range(len(ns) - chunk_size))

print(solve())
```
여기서 `chunk_size`는 한 번에 곱할 연속한 숫자의 개수입니다. 이 값을 4나 5로 바꾸어서 문제에서 제시한 힌트에 맞게 코드를
작성했는지를 검토할 수 있습니다.

이 문제는 코드는 짧지만 약간 읽기 어렵게 느껴질 수도 있습니다. list compreshension 문법을 적극적으로 사용한대다,
map이나 reduce, lambda 와 같은 고차함수 관련 문법은 이전에 C 언어 외에 다른 언어에 대한 문법이 익숙치 않으면 어렵게
느껴질 수 있습니다. 제가 오일러 문제 1번에서도 한 번 말씀드렸죠. 그 문제는 엄청 간단해서 딱 for 루프와 분기를 사용하는 코드가 머리
속에 '팟!' 하도 떠올랐을 수도 있지만, 파이썬에서는 대부분이 이러한 고차함수 문법을 사용하는 경우가 많습니다.

![](/images/photo-1585178332093-1dfaa3998f6b-3_1.jpeg)

## Wireframe 구독하기

가끔은 유용할지도

Subscribe

Email sent! Check your inbox to complete your signup.

No spam. Unsubscribe anytime.

