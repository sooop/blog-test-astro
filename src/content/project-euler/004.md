---
title: "프로젝트 오일러 004"
published_date: 2024-10-04T00:00:00.000Z
modified_date: 2024-10-04T00:00:00.000Z
slug: project-euler-004
custom_excerpt: "앞에서부터 읽을 때나 뒤에서부터 읽을 때나 같은 대칭수 찾기"
feature_image: https://images.unsplash.com/photo-1635070041078-e363dbe005cb?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&q=80&w=2000
category: ""
tags: ["#project-euler"]
---
앞에서부터 읽을 때나 뒤에서부터 읽을 때나 모양이 같은 수를 대칭수라고 합니다. 어떤 정수 N이 대칭수인지 알아보려면 각자리 숫자의 리스트로 분해한 후, 그 리스트가 대칭인지를 보면 됩니다. 가장 간편한 방법은 `reversed`를 사용해서 뒤집은 리스트와 원래의 리스트가 같은지를 보면 됩니다. 

그러나 이 문제에서는 이런 연산을 아주 많이 해야 합니다. 따라서 빠른 시간 내에 답을 찾는 코드를 작성하려면 이 연산에 드는 시간을 최소화할 필요가 있습니다. 경험적으로 가장 빠른 방법은 정수를 문자열 s로 변환한 후,이 문자열을 뒤집은 것이 같은지 체크하는 것입니다. 

세 자리 정수 2개를 선택하는 방법은 810만 가지가 있지만, a × b = b × a 이므로 뒤에 있는 수가 같거나 더 큰 경우만 생각하면 루프의 횟수를 절반으로 줄일 수 있습니다.

```python
ispal = lambda n: str(n) == ''.join(str(n)[::-1])
pals = set()

for x in range(100, 1000):
	for y in range(y, 1000):
		z = x * y
		if ispal(z):
			pals.add(z)

print(max(pals))
```

간단하게 풀 수 있지만 여기서도 개선할 수 있는 여지가 있습니다. '가장 큰 대칭수'를 찾으면서 작은 값부터 비교했다는 것입니다. 

자 세 자리 자연수 두 개의 곱은 999의 제곱이 최대입니다. 그래서 여기서부터 내려오면서 대칭수이고, 그 대칭수가 세 자리 자연수 두 개의 곱으로 표현되는지를 찾으면 됩니다. 정수 A가 세 자리 자연수의 곱인지는 100부터 A의 제곱근 사이의 값을 나눠서 나누어 떨어지는 3자리 몫이 있는지를 검사하면 됩니다.  약간 복잡해보이지만 전수 조사를 할 필요가 없기 때문에 더 빠르게 처리합니다. 

```python
def check_number(n: int) -> bool:
	for m in range(100, int(n**0.5 + 1)):
		x, y = divmod(n, m)
		if y == 0 and 99 < x < 1000:
			return True
	return False

for x in range(999_999, 10000, -1):
	if ispal(x) and check_number(x):
		print(x)
		break
```

