---
layout: ../../../layouts/MarkdownLayout.astro
title: "Project Euler 008"
---

1,000개의 한자리 자연수가 있고, 이를 순서대로 13개씩 골라, 이 13개의 숫자를 모두 곱한 값을 중에서 최대값을 찾는 문제입니다. 주어진 숫자들을 일렬로 늘어선 정수의 리스트로 만들 수 있다면 부분열의 누적곱을 구하는 것이기에 구현은 매우 간단합니다. 그리고 '최대값'을 구해야 하기에 전수조사를 해야하는 문제입니다. 

```python
from functools import reduce

prod = lambda xs: reduce(lambda x, y: x * y, xs)
chunk_size = 13
s = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450 
"""

ns = list(map(int, (c for c in s if c.isdigit())))
print(max(prod(ns[i:i+chunk_size] for i in range(len(ns) - chunk_size))))
```

풀이를 게시하는 사람에 따라서는 문제에 공개된 문자열을 편집기에서 한 줄짜리 문자열로 바꿔서 넣는 경우도 있지만, 여기서는 원문 그대로의 형식을 가져와서 사용했습니다.

### 코드가 읽기 어려운데요

파이썬에서는 코드의 가독성이 매우 중요합니다. 그런데 위 코드는 사실 함수 호출식이 중첩되어 있어서 그렇게 가독성이 좋지는 않아 보입니다. 그럼에도 불구하고 다음과 같은 데이터 처리 흐름에 익숙해지면, 개별 값이 아닌 리스트/배열 단위로 로직을 생각하는 연습이 됩니다. 그리고 보다 간결하고 이해하기 쉬운 코드를 작성하는데 도움이 됩니다. 

- 지능형 리스트(list comprehension)
- `map`, `filter`, reduce


### 보너스 : Julia 풀이

```julia
s = """
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
"""

@time begin
    y = [parse(Int, c) for c = s if isdigit(c)]
    ys = Channel() do ch
        i = 1
        while i + 13 < 1000
            put!(ch, prod(y[i:i+12]))
            i += 1
        end
    end
    foldl(max, ys) |> println
end
```